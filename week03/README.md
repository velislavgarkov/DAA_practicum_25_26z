# Упражнение 3 по ДАА-практикум
- Повече за различните partition-и на quick-sort: https://www.geeksforgeeks.org/dsa/quick-sort-algorithm/
- Интуитивно обяснение на head sort: https://www.geeksforgeeks.org/dsa/heap-sort/
- Подробен анализ на сложността на quickselect в най-лошия, най-добрия и средния случай: https://www.baeldung.com/cs/quickselect

Оттук нататък ще можете да използвате функцията std::sort() без никакви проблеми.
Подобно, няма да има нужда сами да си пишете heap-a - можете да ползвате класа [priority_queue](https://en.cppreference.com/w/cpp/container/priority_queue.html) в С++.

# Обяснение по последната задача - casting
Решението със сложност О(N*M) не ни представлява голям интерес - просто за всеки певец търсим в кое студио да го пратим.
А какво ако искаме решение с по-добра сложност?

Така или иначе сортираме певците по ред на обслужване. Трябва ни начин да избираме бързо студиото за всеки певец.
Нека имаме 2 heap-a. В единия heap, във всеки момент от алгоритъма ще пазим номерата на тези студия, които са свободни.
Ако в даден момент трябва да изберем студио за някой певец, ще изберем този от heap-a на свободните студия, който е с най-малък индекс.
Тоест ни трябва минимален heap.

Какво става ако няма свободни студия? За това ще ползваме втори heap, в който ще пазим студията, които са заети,
както и кога се освобождават. Във всеки момент на алгоритъма ще искаме да поддържаме този heap да е съдържа точно тези студия, тоест ще се налага да местим елементи от него в другия heap, когато някое студио се освобождава.

И когато видим, че няма свободни студия, ще вземем първото, което се освобождава. Ако има няколко такива, ще вземем това с най-малък индекс.
Реално ще е достатъчно да вземем най-малката наредена двойка (време на освобождаване, индекс). Тоест пак ни трябва минимален heap.
В кода е написано за по-голяма яснота, че това студио първо го добавяме в heap-a на свободните студия и след това го назначаваме на текущия певец. По-бавно е, но няма да промени сложността, а и се чете по-лесно.

Остава да анализираме сложността на това решение. Трябва да гледаме какво се случва амортизирано със сложността, защото в даден момент можем да местим много елементи от един heap в друг, а в друг момент може директно да обслужваме певец.
Първоначално всички студия ги добавяме в първия heap за свободните. Сложостта на това е O(NlogN) (в решението ги добавяме един по един, можем и да направим heapify на цялата редица от студия за О(N), но няма да има особена разлика).
Да разгледаме студиото, което назначаваме на някой фиксиран певец. Тогава това студио го местим в heap-a на заетите студия. След това по някое време евентуално това студио ще бъде преместено в heap-a на свободните. Тоест за всеки певец правим 2 местения на елементи в heap-овете, макар и второто местене да става по-късно.
Така сложността става О(MlogN).
